<?xml version="1.0" ?>
<SmellBaseline>
  <ManuallySuppressedIssues/>
  <CurrentIssues>
    <ID>CommentWrapping:SignalMetrics.kt$Metric.SNR$/* Selected 12 as the max to get 4 equal vertical sections. */</ID>
    <ID>ComposableParamOrder:DeviceMetrics.kt$DeviceMetricsChart</ID>
    <ID>ComposableParamOrder:ElevationInfo.kt$ElevationInfo</ID>
    <ID>ComposableParamOrder:EnvironmentCharts.kt$ChartContent</ID>
    <ID>ComposableParamOrder:EnvironmentCharts.kt$EnvironmentMetricsChart</ID>
    <ID>ComposableParamOrder:EnvironmentCharts.kt$MetricPlottingCanvas</ID>
    <ID>ComposableParamOrder:HostMetricsLog.kt$HostMetricsItem</ID>
    <ID>ComposableParamOrder:HostMetricsLog.kt$LogLine</ID>
    <ID>ComposableParamOrder:LastHeardInfo.kt$LastHeardInfo</ID>
    <ID>ComposableParamOrder:NodeFilterTextField.kt$NodeFilterTextField</ID>
    <ID>ComposableParamOrder:NodeItem.kt$NodeItem</ID>
    <ID>ComposableParamOrder:PaxMetrics.kt$PaxMetricsChart</ID>
    <ID>ComposableParamOrder:PowerMetrics.kt$PowerMetricsChart</ID>
    <ID>ComposableParamOrder:SatelliteCountInfo.kt$SatelliteCountInfo</ID>
    <ID>ComposableParamOrder:SignalMetrics.kt$SignalMetricsChart</ID>
    <ID>ComposableParamOrder:TracerouteButton.kt$TracerouteButton</ID>
    <ID>LambdaParameterEventTrailing:TracerouteLog.kt$onNavigateUp</ID>
    <ID>LongMethod:EnvironmentMetrics.kt$@Composable fun EnvironmentMetricsScreen(viewModel: MetricsViewModel = hiltViewModel(), onNavigateUp: () -&gt; Unit)</ID>
    <ID>LongMethod:NodeDetailsSection.kt$@Composable private fun MainNodeDetails(node: Node)</ID>
    <ID>MagicNumber:MetricsViewModel.kt$MetricsViewModel$1000L</ID>
    <ID>MagicNumber:MetricsViewModel.kt$MetricsViewModel$1e-5</ID>
    <ID>MagicNumber:MetricsViewModel.kt$MetricsViewModel$1e-7</ID>
    <ID>ModifierMissing:CommonCharts.kt$ChartHeader</ID>
    <ID>ModifierMissing:CommonCharts.kt$Legend</ID>
    <ID>ModifierMissing:CommonCharts.kt$TimeLabels</ID>
    <ID>ModifierMissing:DeviceMetrics.kt$DeviceMetricsScreen</ID>
    <ID>ModifierMissing:EnvironmentMetrics.kt$EnvironmentMetricsScreen</ID>
    <ID>ModifierMissing:HostMetricsLog.kt$HostMetricsLogScreen</ID>
    <ID>ModifierMissing:NodeListScreen.kt$NodeListScreen</ID>
    <ID>ModifierMissing:NodeStatusIcons.kt$NodeStatusIcons</ID>
    <ID>ModifierMissing:PaxMetrics.kt$PaxMetricsItem</ID>
    <ID>ModifierMissing:PaxMetrics.kt$PaxMetricsScreen</ID>
    <ID>ModifierMissing:PositionLog.kt$PositionItem</ID>
    <ID>ModifierMissing:PositionLog.kt$PositionLogScreen</ID>
    <ID>ModifierMissing:PowerMetrics.kt$PowerMetricsScreen</ID>
    <ID>ModifierMissing:SignalMetrics.kt$SignalMetricsScreen</ID>
    <ID>ModifierNotUsedAtRoot:DeviceMetrics.kt$modifier = modifier.weight(weight = Y_AXIS_WEIGHT)</ID>
    <ID>ModifierNotUsedAtRoot:DeviceMetrics.kt$modifier = modifier.width(dp)</ID>
    <ID>ModifierNotUsedAtRoot:DeviceMetrics.kt$modifier.width(dp)</ID>
    <ID>ModifierNotUsedAtRoot:EnvironmentCharts.kt$modifier = modifier.width(dp)</ID>
    <ID>ModifierNotUsedAtRoot:EnvironmentCharts.kt$modifier.width(dp)</ID>
    <ID>ModifierNotUsedAtRoot:PaxMetrics.kt$modifier.width(dp)</ID>
    <ID>ModifierNotUsedAtRoot:PowerMetrics.kt$modifier = modifier.weight(weight = Y_AXIS_WEIGHT)</ID>
    <ID>ModifierNotUsedAtRoot:PowerMetrics.kt$modifier = modifier.width(dp)</ID>
    <ID>ModifierNotUsedAtRoot:PowerMetrics.kt$modifier.width(dp)</ID>
    <ID>ModifierNotUsedAtRoot:SignalMetrics.kt$modifier = modifier.weight(weight = Y_AXIS_WEIGHT)</ID>
    <ID>ModifierNotUsedAtRoot:SignalMetrics.kt$modifier = modifier.width(dp)</ID>
    <ID>ModifierNotUsedAtRoot:SignalMetrics.kt$modifier.width(dp)</ID>
    <ID>ModifierNotUsedAtRoot:TracerouteLog.kt$modifier = modifier.fillMaxSize().padding(innerPadding)</ID>
    <ID>ModifierReused:DeviceMetrics.kt$Canvas(modifier = modifier.width(dp)) { val height = size.height val width = size.width for (i in telemetries.indices) { val telemetry = telemetries[i] /* x-value time */ val xRatio = (telemetry.time - oldest.time).toFloat() / timeDiff val x = xRatio * width /* Channel Utilization */ plotPoint( drawContext = drawContext, color = Device.CH_UTIL.color, x = x, value = telemetry.deviceMetrics.channelUtilization, divisor = MAX_PERCENT_VALUE, ) /* Air Utilization Transmit */ plotPoint( drawContext = drawContext, color = Device.AIR_UTIL.color, x = x, value = telemetry.deviceMetrics.airUtilTx, divisor = MAX_PERCENT_VALUE, ) } /* Battery Line */ var index = 0 while (index &lt; telemetries.size) { val path = Path() index = createPath( telemetries = telemetries, index = index, path = path, oldestTime = oldest.time, timeRange = timeDiff, width = width, timeThreshold = selectedTime.timeThreshold(), ) { i -&gt; val telemetry = telemetries.getOrNull(i) ?: telemetries.last() val ratio = telemetry.deviceMetrics.batteryLevel / MAX_PERCENT_VALUE val y = height - (ratio * height) return@createPath y } drawPath( path = path, color = Device.BATTERY.color, style = Stroke(width = GraphUtil.RADIUS, cap = StrokeCap.Round), ) } }</ID>
    <ID>ModifierReused:DeviceMetrics.kt$HorizontalLinesOverlay( modifier.width(dp), lineColors = listOf(graphColor, Color.Yellow, Color.Red, graphColor, graphColor), )</ID>
    <ID>ModifierReused:DeviceMetrics.kt$TimeAxisOverlay(modifier.width(dp), oldest = oldest.time, newest = newest.time, selectedTime.lineInterval())</ID>
    <ID>ModifierReused:EnvironmentCharts.kt$Box( contentAlignment = Alignment.TopStart, modifier = modifier.horizontalScroll(state = scrollState, reverseScrolling = true), ) { HorizontalLinesOverlay(modifier.width(dp), lineColors = List(size = 5) { graphColor }) TimeAxisOverlay(modifier = modifier.width(dp), oldest = oldest, newest = newest, selectedTime.lineInterval()) MetricPlottingCanvas( modifier = modifier.width(dp), telemetries = telemetries, graphData = graphData, selectedTime = selectedTime, oldest = oldest, timeDiff = timeDiff, rightMin = rightMin, rightMax = rightMax, ) }</ID>
    <ID>ModifierReused:EnvironmentCharts.kt$HorizontalLinesOverlay(modifier.width(dp), lineColors = List(size = 5) { graphColor })</ID>
    <ID>ModifierReused:EnvironmentCharts.kt$MetricPlottingCanvas( modifier = modifier.width(dp), telemetries = telemetries, graphData = graphData, selectedTime = selectedTime, oldest = oldest, timeDiff = timeDiff, rightMin = rightMin, rightMax = rightMax, )</ID>
    <ID>ModifierReused:EnvironmentCharts.kt$TimeAxisOverlay(modifier = modifier.width(dp), oldest = oldest, newest = newest, selectedTime.lineInterval())</ID>
    <ID>ModifierReused:PaxMetrics.kt$HorizontalLinesOverlay(modifier.width(dp), lineColors = List(size = 5) { Color.LightGray })</ID>
    <ID>ModifierReused:PaxMetrics.kt$Row(modifier = modifier.fillMaxWidth().fillMaxHeight(fraction = 0.33f)) { YAxisLabels( modifier = Modifier.weight(Y_AXIS_WEIGHT).fillMaxHeight().padding(start = 8.dp), labelColor = MaterialTheme.colorScheme.onSurface, minValue = minValue, maxValue = maxValue, ) Box( contentAlignment = Alignment.TopStart, modifier = Modifier.horizontalScroll(state = scrollState, reverseScrolling = true).weight(CHART_WEIGHT), ) { HorizontalLinesOverlay(modifier.width(dp), lineColors = List(size = 5) { Color.LightGray }) TimeAxisOverlay(modifier.width(dp), oldest = minTime, newest = maxTime, timeFrame.lineInterval()) Canvas(modifier = Modifier.width(dp).fillMaxHeight()) { val width = size.width val height = size.height fun xForTime(t: Int): Float = if (maxTime == minTime) width / 2 else (t - minTime).toFloat() / (maxTime - minTime) * width fun yForValue(v: Int): Float = height - (v - minValue) / (maxValue - minValue) * height fun drawLine(series: List&lt;Pair&lt;Int, Int&gt;&gt;, color: Color) { for (i in 1 until series.size) { drawLine( color = color, start = Offset(xForTime(series[i - 1].first), yForValue(series[i - 1].second)), end = Offset(xForTime(series[i].first), yForValue(series[i].second)), strokeWidth = 2.dp.toPx(), ) } } drawLine(bleSeries, PaxSeries.BLE.color) drawLine(wifiSeries, PaxSeries.WIFI.color) drawLine(totalSeries, PaxSeries.PAX.color) } } YAxisLabels( modifier = Modifier.weight(Y_AXIS_WEIGHT).fillMaxHeight().padding(end = 8.dp), labelColor = MaterialTheme.colorScheme.onSurface, minValue = minValue, maxValue = maxValue, ) }</ID>
    <ID>ModifierReused:PaxMetrics.kt$TimeAxisOverlay(modifier.width(dp), oldest = minTime, newest = maxTime, timeFrame.lineInterval())</ID>
    <ID>ModifierReused:PowerMetrics.kt$Canvas(modifier = modifier.width(dp)) { val width = size.width val height = size.height /* Voltage */ var index = 0 while (index &lt; telemetries.size) { val path = Path() index = createPath( telemetries = telemetries, index = index, path = path, oldestTime = oldest.time, timeRange = timeDiff, width = width, timeThreshold = selectedTime.timeThreshold(), ) { i -&gt; val telemetry = telemetries.getOrNull(i) ?: telemetries.last() val ratio = (retrieveVoltage(selectedChannel, telemetry) - voltageMin) / voltageDiff val y = height - (ratio * height) return@createPath y } drawPath( path = path, color = VOLTAGE_COLOR, style = Stroke(width = GraphUtil.RADIUS, cap = StrokeCap.Round), ) } /* Current */ index = 0 while (index &lt; telemetries.size) { val path = Path() index = createPath( telemetries = telemetries, index = index, path = path, oldestTime = oldest.time, timeRange = timeDiff, width = width, timeThreshold = selectedTime.timeThreshold(), ) { i -&gt; val telemetry = telemetries.getOrNull(i) ?: telemetries.last() val ratio = (retrieveCurrent(selectedChannel, telemetry) - Power.CURRENT.min) / currentDiff val y = height - (ratio * height) return@createPath y } drawPath( path = path, color = Power.CURRENT.color, style = Stroke(width = GraphUtil.RADIUS, cap = StrokeCap.Round), ) } }</ID>
    <ID>ModifierReused:PowerMetrics.kt$HorizontalLinesOverlay(modifier.width(dp), lineColors = List(size = 5) { graphColor })</ID>
    <ID>ModifierReused:PowerMetrics.kt$TimeAxisOverlay(modifier.width(dp), oldest = oldest.time, newest = newest.time, selectedTime.lineInterval())</ID>
    <ID>ModifierReused:PowerMetrics.kt$YAxisLabels( modifier = modifier.weight(weight = Y_AXIS_WEIGHT), Power.CURRENT.color, minValue = Power.CURRENT.min, maxValue = Power.CURRENT.max, )</ID>
    <ID>ModifierReused:PowerMetrics.kt$YAxisLabels( modifier = modifier.weight(weight = Y_AXIS_WEIGHT), VOLTAGE_COLOR, minValue = voltageMin, maxValue = voltageMax, )</ID>
    <ID>ModifierReused:SignalMetrics.kt$Canvas(modifier = modifier.width(dp)) { val width = size.width /* Plot */ for (packet in meshPackets) { val xRatio = (packet.rxTime - oldest.rxTime).toFloat() / timeDiff val x = xRatio * width /* SNR */ plotPoint( drawContext = drawContext, color = Metric.SNR.color, x = x, value = packet.rxSnr - Metric.SNR.min, divisor = snrDiff, ) /* RSSI */ plotPoint( drawContext = drawContext, color = Metric.RSSI.color, x = x, value = packet.rxRssi - Metric.RSSI.min, divisor = rssiDiff, ) } }</ID>
    <ID>ModifierReused:SignalMetrics.kt$HorizontalLinesOverlay(modifier.width(dp), lineColors = List(size = 5) { graphColor })</ID>
    <ID>ModifierReused:SignalMetrics.kt$TimeAxisOverlay( modifier.width(dp), oldest = oldest.rxTime, newest = newest.rxTime, selectedTime.lineInterval(), )</ID>
    <ID>ModifierReused:SignalMetrics.kt$YAxisLabels( modifier = modifier.weight(weight = Y_AXIS_WEIGHT), Metric.RSSI.color, minValue = Metric.RSSI.min, maxValue = Metric.RSSI.max, )</ID>
    <ID>ModifierReused:SignalMetrics.kt$YAxisLabels( modifier = modifier.weight(weight = Y_AXIS_WEIGHT), Metric.SNR.color, minValue = Metric.SNR.min, maxValue = Metric.SNR.max, )</ID>
    <ID>ModifierWithoutDefault:CommonCharts.kt$modifier</ID>
    <ID>ModifierWithoutDefault:EnvironmentCharts.kt$modifier</ID>
    <ID>MultipleEmitters:CommonCharts.kt$LegendLabel</ID>
    <ID>MultipleEmitters:DeviceMetrics.kt$DeviceMetricsChart</ID>
    <ID>MultipleEmitters:EnvironmentCharts.kt$EnvironmentMetricsChart</ID>
    <ID>MultipleEmitters:NodeDetailsSection.kt$MainNodeDetails</ID>
    <ID>MultipleEmitters:PaxMetrics.kt$PaxMetricsChart</ID>
    <ID>MultipleEmitters:PowerMetrics.kt$PowerMetricsChart</ID>
    <ID>MultipleEmitters:RemoteDeviceActions.kt$RemoteDeviceActions</ID>
    <ID>MultipleEmitters:SignalMetrics.kt$SignalMetricsChart</ID>
    <ID>ParameterNaming:NodeFilterTextField.kt$onToggleShowIgnored</ID>
    <ID>PreviewPublic:NodeItem.kt$NodeInfoPreview</ID>
    <ID>PreviewPublic:NodeItem.kt$NodeInfoSimplePreview</ID>
  </CurrentIssues>
</SmellBaseline>
